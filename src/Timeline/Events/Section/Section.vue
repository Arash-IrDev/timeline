<script setup lang="ts">
import { computed, ref, watch } from "vue";
import { useTimelineStore } from "@/Timeline/timelineStore";
import type { NodeArray, SomeNode } from "@markwhen/parser/lib/Node";
import { useEventColor } from "../composables/useEventColor";
import ExpandedSectionBackground from "./ExpandedSectionBackground.vue";
import { toInnerHtml } from "@/Timeline/utilities/innerHtml";
import SectionHeader from "./SectionHeader.vue";
import { ranges } from "@/utilities/ranges";
import { equivalentPaths, type EventPath } from "@/Timeline/paths";
import { recurrenceLimit } from "@/Timeline/timelineStore";

const timelineStore = useTimelineStore();
const { setHoveringEvent, clearHoveringEvent } = timelineStore;
const props = defineProps<{
  node: SomeNode;
  path: string;
  numChildren?: number | undefined;
  numAbove: number;
  groupStyle?: "group" | "section";
}>();

const {
  scalelessDistanceBetweenDates,
  scalelessDistanceFromBaselineLeftmostDate,
} = timelineStore;

const collapsed = computed({
  get: () => timelineStore.isCollapsed(props.path),
  set: (val) => timelineStore.setCollapsed(props.path, val),
});
const hovering = ref(false);
const hoveringPath = computed(() => timelineStore.hoveringEventPaths);
const ourPath = computed<EventPath>(() => ({
  type: "pageFiltered",
  path: props.path.split(",").map((i) => parseInt(i)),
}));
const toggle = (e: MouseEvent) => {
  if (e.target instanceof HTMLAnchorElement) {
    return;
  }
  e.preventDefault();
  collapsed.value = !collapsed.value;
};

const sectionRange = computed(() => ranges(props.node, recurrenceLimit));

const left = computed(() => {
  if (!props.node || !sectionRange.value) {
    return 10;
  }
  return scalelessDistanceFromBaselineLeftmostDate(
    sectionRange.value.fromDateTime
  );
});

const { color } = useEventColor(props.node);

const fullWidth = computed(() => {
  if (!props.node || !sectionRange.value) {
    return 100;
  }
  return scalelessDistanceBetweenDates(
    sectionRange.value.fromDateTime,
    sectionRange.value.toDateTime
  );
});
const titleHtml = computed(() => toInnerHtml(props.node.title || ""));

const hover = (isHovering: boolean) => {
  hovering.value = isHovering;
};

watch(hovering, (h) => {
  if (h) {
    setHoveringEvent(props.node.rangeInText!.from);
  } else {
    clearHoveringEvent();
  }
});

const groupStyle = computed(() =>
  props.groupStyle
    ? props.groupStyle
    : timelineStore.mode === "gantt"
    ? "section"
    : props.node.style === "section"
    ? "section"
    : "group"
);

const width = computed(
  () => `${timelineStore.pageScaleBy24 * fullWidth.value}px`
);

const top = computed(() => 100 + props.numAbove * 30);

const height = computed(() => 30 + props.numChildren! * 30);

const styleObject = computed(() => ({
  top: `${top.value}px`,
  transition: `top 200ms cubic-bezier(0.4, 0, 0.2, 1)`,
  display: timelineStore.isCollapsedChild(props.path) ? "none" : "block",
  ...(groupStyle.value === "section"
    ? {
        left: 0,
        right: 0,
      }
    : {}),
}));

const hovered = computed(
  () =>
    hovering.value ||
    equivalentPaths(hoveringPath.value?.pageFiltered, ourPath.value)
);
</script>

<template>
  <div class="absolute" :style="styleObject">
    <div class="relative flex flex-col">
      <ExpandedSectionBackground
        :hovering="hovered"
        :style="groupStyle"
        :node="node"
        :left="left"
        :height="height"
        :full-width="fullWidth"
        :path="path"
      />
      <div
        class="sticky top-0 cursor-pointer"
        :style="{
          width,
        }"
      ></div>
      <SectionHeader
        :path="path"
        @toggle="toggle"
        @hover="hover"
        :hovering="hovered"
        :expanded="!collapsed"
        :titleHtml="titleHtml"
        :color="color"
        :num-children="(node.value as NodeArray).length"
        :group-style="groupStyle"
        :left="left"
        :full-width="fullWidth"
      ></SectionHeader>
    </div>
  </div>
</template>

<style scoped></style>
